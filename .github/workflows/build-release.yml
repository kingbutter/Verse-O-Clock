name: Build & Release (devices)

on:
  workflow_dispatch:
  push:
    tags: ["v*"]

permissions:
  contents: write

jobs:
  # ------------------------------------------------------------
  # Generate a device build matrix from devices.json
  # ------------------------------------------------------------
  matrix:
    runs-on: ubuntu-latest
    outputs:
      include: ${{ steps.mk.outputs.include }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build matrix from devices.json
        id: mk
        shell: bash
        run: |
          python - <<'PY'
          import json, os
          from pathlib import Path

          cfg = json.loads(Path("devices.json").read_text(encoding="utf-8"))
          include = []

          for d in cfg.get("devices", []):
            device_id = d["id"]
            sketch = f"devices/{device_id}"

            fqbn = d["board"]
            ps = d.get("partition_scheme")
            if ps:
              fqbn = f"{fqbn}:PartitionScheme={ps}"

            raw = d.get("display", {}).get("busy_polarity_patch", False)
            if isinstance(raw, bool):
              busy_patch = raw
            elif raw is None:
              busy_patch = False
            else:
              busy_patch = str(raw).strip().lower() in ("1", "true", "yes", "y", "on")

            display = d.get("display", {}) or {}
            driver_class = display.get("driver_class", "")
            busy_level = (display.get("busy_level", "HIGH") or "HIGH").strip().upper()

            include.append({
              "id": device_id,
              "sketch": sketch,
              "fqbn": fqbn,
              "busy_patch": busy_patch,
              "driver_class": driver_class,
              "busy_level": busy_level,
            })

          out = {"device": include}

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as f:
            f.write("include=" + json.dumps(out) + "\n")

          print(json.dumps(out, indent=2))
          PY

  build:
    needs: matrix
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.matrix.outputs.include) }}

    steps:
      # ------------------------------------------------------------
      # Checkout + toolchains
      # ------------------------------------------------------------
      - name: Checkout
        uses: actions/checkout@v4

      - name: Dump matrix JSON
        run: |
          echo '${{ toJson(matrix) }}'


      - name: Install Arduino CLI
        uses: arduino/setup-arduino-cli@v2

      - name: Install ESP32 core
        shell: bash
        run: |
          set -euo pipefail
          arduino-cli config init
          arduino-cli config set board_manager.additional_urls https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json
          arduino-cli core update-index
          arduino-cli core install esp32:esp32

      # ------------------------------------------------------------
      # Libraries
      # ------------------------------------------------------------
      - name: Install Arduino libraries
        shell: bash
        run: |
          set -euo pipefail
          # Needed for --git-url installs with arduino-cli >= 1.4
          arduino-cli config set library.enable_unsafe_install true
          arduino-cli lib update-index

          arduino-cli lib install "WiFiManager"
          arduino-cli lib install "GxEPD2"
          arduino-cli lib install "Adafruit GFX Library"
          # Force Unishox from upstream GitHub repo
          arduino-cli lib install --git-url https://github.com/siara-cc/Unishox_Arduino_lib.git

      - name: Ensure GxEPD2 BUSY level (device flag)
        if: ${{ matrix.device.busy_patch }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Ensuring BUSY level for ${{ matrix.device.id }} driver=${{ matrix.device.driver_class }} busy_level=${{ matrix.device.busy_level }}"

          python - <<'PY'
          from pathlib import Path
          import os, re

          driver = "${{ matrix.device.driver_class }}".strip()
          want  = "${{ matrix.device.busy_level }}".strip().upper()
          if want not in ("HIGH", "LOW"):
            raise SystemExit(f"ERROR: busy_level must be HIGH or LOW, got: {want}")
          if not driver:
            raise SystemExit("ERROR: driver_class is empty (set display.driver_class in devices.json)")

          home = Path(os.environ.get("HOME", str(Path.home())))
          sketch_dir = Path("${{ matrix.device.sketch }}")

          roots = [
            Path.cwd() / "libraries" / "GxEPD2",
            sketch_dir / "libraries" / "GxEPD2",
            home / "Arduino" / "libraries" / "GxEPD2",
            home / "Documents" / "Arduino" / "libraries" / "GxEPD2",
          ]
          roots = [r for r in roots if r.exists()]
          if not roots:
            raise SystemExit("ERROR: GxEPD2 not found in expected locations.")

          # Find driver implementation file
          cpp = None
          for root in roots:
            p = root / "src"
            if not p.exists():
              continue
            cand = list(p.rglob(f"{driver}.cpp"))
            if cand:
              cpp = cand[0]
              break
          if not cpp:
            raise SystemExit(f"ERROR: Could not find {driver}.cpp under any GxEPD2/src root.")

          text = cpp.read_text(encoding="utf-8", errors="ignore")

          # Match: GxEPD2_EPD(cs, dc, rst, busy, <LEVEL>,
          pat = r"(GxEPD2_EPD\(\s*cs\s*,\s*dc\s*,\s*rst\s*,\s*busy\s*,\s*)(HIGH|LOW)(\s*,)"
          m = re.search(pat, text)
          if not m:
            raise SystemExit(f"ERROR: Couldn't find GxEPD2_EPD(... busy, <LEVEL>, ...) in {cpp}")

          have = m.group(2)
          if have == want:
            print(f"OK: {cpp} already has busy_level={want}")
            print("[proof]", m.group(0))
            raise SystemExit(0)

          new, n = re.subn(pat, r"\g<1>" + want + r"\3", text, count=1)
          cpp.write_text(new, encoding="utf-8")
          print(f"Patched {cpp}: {have} -> {want} (replacements={n})")

          m2 = re.search(pat, new)
          if m2:
            print("[proof]", m2.group(0))
          PY



      # ------------------------------------------------------------
      # Build verse data (Python â†’ device data/)
      # ------------------------------------------------------------
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Build verse assets into device data/ (${{ matrix.device.id }})
        shell: bash
        working-directory: ${{ matrix.device.sketch }}
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install unishox2-py3
          # helpers/ lives at repo root
          python ../../helpers/build_verses_unishox.py

      # ------------------------------------------------------------
      # Compile firmware
      # ------------------------------------------------------------
      - name: Compile firmware (${{ matrix.device.id }})
        shell: bash
        run: |
          set -euo pipefail

          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            EXTRA_CPP_FLAGS="-DRELEASE_BUILD=1 -DFW_VERSION=\"${GITHUB_REF_NAME}\""
          else
            EXTRA_CPP_FLAGS=""
          fi

          arduino-cli compile \
            --libraries "./common" \
            --fqbn "${{ matrix.device.fqbn }}" \
            --export-binaries \
            --build-path "${{ matrix.device.sketch }}/build" \
            --build-property "compiler.cpp.extra_flags=${EXTRA_CPP_FLAGS}" \
            "${{ matrix.device.sketch }}"


      # ------------------------------------------------------------
      # Build LittleFS image from data/ (IDE-like partitions.csv resolution)
      # ------------------------------------------------------------
      - name: Build LittleFS image (${{ matrix.device.id }})
        shell: bash
        run: |
          set -euo pipefail

          SKETCH_DIR="${{ matrix.device.sketch }}"
          FQBN="${{ matrix.device.fqbn }}"
          DATA_DIR="$SKETCH_DIR/data"

          # Resolve partitions.csv the same way Arduino IDE / ESP32 core does:
          # - If sketch folder contains partitions.csv, that overrides the board's built-in scheme.
          # - Otherwise, derive the built-in partitions CSV from arduino-cli --show-properties.
          PART_CSV="$SKETCH_DIR/partitions.csv"

          if [[ ! -f "$PART_CSV" ]]; then
            PROPS="$(arduino-cli compile --libraries "./common" --fqbn "$FQBN" --show-properties --build-path "$SKETCH_DIR/build" "$SKETCH_DIR")"
            RUNTIME_PLATFORM_PATH="$(printf "%s\n" "$PROPS" | awk -F= '$1=="runtime.platform.path"{print $2; exit}')"
            BUILD_PARTITIONS="$(printf "%s\n" "$PROPS" | awk -F= '$1=="build.partitions"{print $2; exit}')"

            if [[ -z "${RUNTIME_PLATFORM_PATH}" || -z "${BUILD_PARTITIONS}" ]]; then
              echo "ERROR: Could not determine runtime.platform.path/build.partitions from --show-properties"
              exit 1
            fi

            PART_CSV="$RUNTIME_PLATFORM_PATH/tools/partitions/${BUILD_PARTITIONS}.csv"
            if [[ ! -f "$PART_CSV" ]]; then
              echo "ERROR: Built-in partitions CSV not found: $PART_CSV"
              exit 1
            fi
          fi

          echo "Using partitions CSV: $PART_CSV"

          LFS_OFF_HEX="$(awk -F',' '$1 ~ /^[[:space:]]*littlefs[[:space:]]*$/ {gsub(/[[:space:]]/,"",$4); print $4; exit}' "$PART_CSV")"
          LFS_SIZE_HEX="$(awk -F',' '$1 ~ /^[[:space:]]*littlefs[[:space:]]*$/ {gsub(/[[:space:]]/,"",$5); print $5; exit}' "$PART_CSV")"

          if [[ -z "$LFS_SIZE_HEX" ]]; then
            echo "ERROR: littlefs partition not found in: $PART_CSV"
            exit 1
          fi

          LFS_SIZE_BYTES=$((LFS_SIZE_HEX))

          # Robustly get Arduino CLI data dir (JSON). Fallback to default location.
          CORE_DATA="$(arduino-cli config dump --format json 2>/dev/null | python -c "import json,sys; print(json.load(sys.stdin).get('directories',{}).get('data',''))" || true)"
          [[ -n "${CORE_DATA}" ]] || CORE_DATA="$HOME/.arduino15"

          MKL="$(find "$CORE_DATA/packages/esp32/tools" -type f -name mklittlefs -print -quit 2>/dev/null || true)"
          if [[ -z "${MKL}" ]]; then
            echo "ERROR: mklittlefs not found under $CORE_DATA/packages/esp32/tools"
            arduino-cli core list || true
            exit 1
          fi

          mkdir -p dist
          "$MKL" -c "$DATA_DIR" -s "$LFS_SIZE_BYTES" "dist/${{ matrix.device.id }}_littlefs.bin"
          echo "$LFS_OFF_HEX" > "dist/${{ matrix.device.id }}_littlefs_offset.txt"

      # ------------------------------------------------------------
      # Collect firmware + devices.json
      # ------------------------------------------------------------
      - name: Collect artifacts
        shell: bash
        run: |
          set -euo pipefail

          SKETCH_DIR="${{ matrix.device.sketch }}"
          DATA_DIR="$SKETCH_DIR/data"

          # Pick the OTA-safe application binary (Arduino/ESP32 produces *.ino.bin for the sketch)
          APP_BIN="$(find "$SKETCH_DIR/build" -type f -name '*.ino.bin' | head -n 1)"
          if [[ -z "${APP_BIN}" || ! -f "${APP_BIN}" ]]; then
            echo "ERROR: Could not find app binary (*.ino.bin) in $SKETCH_DIR/build"
            echo "Found these .bin files:"
            find "$SKETCH_DIR/build" -type f -name '*.bin' -maxdepth 3 -print || true
            exit 1
          fi

          # Guardrail: never ship a full-flash image as OTA (4MB on XIAO ESP32-C3)
          APP_SIZE="$(stat -c%s "${APP_BIN}")"
          if [[ "${APP_SIZE}" -ge 3000000 ]]; then
            echo "ERROR: App binary is suspiciously large (${APP_SIZE} bytes). Refusing to publish as OTA."
            echo "This usually means you picked a merged/full-flash bin."
            exit 1
          fi

          mkdir -p dist
          cp -v "${APP_BIN}" "dist/${{ matrix.device.id }}_firmware.bin"

          # --- Optional USB recovery artifacts (NOT for OTA) ---

          BOOT_BIN="$(find "$SKETCH_DIR/build" -type f -name '*bootloader*.bin' | head -n 1 || true)"
          PART_BIN="$(find "$SKETCH_DIR/build" -type f -name '*partitions*.bin' | head -n 1 || true)"

          if [[ -f "$BOOT_BIN" ]]; then
            cp -v "$BOOT_BIN" "dist/${{ matrix.device.id }}_bootloader.bin"
          fi

          if [[ -f "$PART_BIN" ]]; then
            cp -v "$PART_BIN" "dist/${{ matrix.device.id }}_partitions.bin"
          fi


          # Always include the littlefs image built earlier
          test -f "dist/${{ matrix.device.id }}_littlefs.bin"

          # Copy content blobs produced by the helper into dist/
          test -f "$DATA_DIR/toc.bin"
          test -f "$DATA_DIR/entries.bin"
          test -f "$DATA_DIR/texts.bin"
          cp -v "$DATA_DIR/toc.bin"     "dist/${{ matrix.device.id }}_toc.bin"
          cp -v "$DATA_DIR/entries.bin" "dist/${{ matrix.device.id }}_entries.bin"
          cp -v "$DATA_DIR/texts.bin"   "dist/${{ matrix.device.id }}_texts.bin"

          # Generate a content manifest (sizes + sha256)
          python - <<'PY'
          import hashlib, json
          from pathlib import Path

          device = "${{ matrix.device.id }}"
          dist = Path("dist")

          def sha256(p: Path) -> str:
            h = hashlib.sha256()
            with p.open("rb") as f:
              for chunk in iter(lambda: f.read(1024 * 1024), b""):
                h.update(chunk)
            return h.hexdigest()

          files = {
            "toc.bin": dist / f"{device}_toc.bin",
            "entries.bin": dist / f"{device}_entries.bin",
            "texts.bin": dist / f"{device}_texts.bin",
          }

          manifest = {"device": device, "files": {}}
          for name, p in files.items():
            if not p.exists():
              raise SystemExit(f"Missing {p}")
            manifest["files"][name] = {
              "size": p.stat().st_size,
              "sha256": sha256(p),
            }

          out = dist / f"{device}_content_manifest.json"
          out.write_text(json.dumps(manifest, indent=2), encoding="utf-8")
          print(f"Wrote {out}")
          PY

          if [[ -f "devices.json" ]]; then
            cp -v devices.json dist/devices.json
          fi


      # ------------------------------------------------------------
      # Upload / Release
      # ------------------------------------------------------------
      - name: Upload artifacts (manual runs)
        if: startsWith(github.ref, 'refs/tags/') != true
        uses: actions/upload-artifact@v4
        with:
          name: firmware-${{ matrix.device.id }}
          path: dist/*

      - name: Resolve release title/body (from releases/<tag>.md)
        if: startsWith(github.ref, 'refs/tags/')
        id: release_meta
        shell: bash
        run: |
          set -euo pipefail
          NOTES="releases/${GITHUB_REF_NAME}.md"
          if [[ ! -f "$NOTES" ]]; then
            echo "ERROR: Release notes file not found: $NOTES"
            exit 1
          fi
          RAW_TITLE="$(head -n 1 "$NOTES")"
          TITLE="$(echo "$RAW_TITLE" | sed -E 's/^#+[[:space:]]*//; s/[[:space:]]+$//')"
          if [[ -z "${TITLE}" ]]; then
            echo "ERROR: First line of $NOTES is empty (used as release title)"
            exit 1
          fi
          echo "title=$TITLE" >> "$GITHUB_OUTPUT"
          echo "body_path=$NOTES" >> "$GITHUB_OUTPUT"

      - name: Publish content to Verse-O-Clock-Content (on tag)
        if: startsWith(github.ref, 'refs/tags/') && matrix.device.id == 'xiao_esp32c3_7p5'
        uses: actions/checkout@v4
        with:
          repository: kingbutter/Verse-O-Clock-Content
          ref: main
          token: ${{ secrets.CONTENT_REPO_TOKEN }}
          path: contentrepo

      - name: Copy content into content repo + commit (on tag)
        if: startsWith(github.ref, 'refs/tags/') && matrix.device.id == 'xiao_esp32c3_7p5'
        shell: bash
        run: |
          set -euo pipefail

          # Publish to repo root for now (single device).
          cp -v "dist/${{ matrix.device.id }}_toc.bin"     "contentrepo/toc.bin"
          cp -v "dist/${{ matrix.device.id }}_entries.bin" "contentrepo/entries.bin"
          cp -v "dist/${{ matrix.device.id }}_texts.bin"   "contentrepo/texts.bin"
          cp -v "dist/${{ matrix.device.id }}_content_manifest.json" "contentrepo/manifest.json"

          cd contentrepo
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add toc.bin entries.bin texts.bin manifest.json
          if git diff --cached --quiet; then
            echo "No content changes to publish."
            exit 0
          fi

          git commit -m "Update Verse-O-Clock content for ${GITHUB_REF_NAME}"
          git push


      - name: Publish GitHub Release (on tag)
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2
        with:
          name: ${{ steps.release_meta.outputs.title }}
          body_path: ${{ steps.release_meta.outputs.body_path }}
          files: dist/*
          generate_release_notes: false
          overwrite_files: true